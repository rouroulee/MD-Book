
### JVM由哪几部分组成
1.类加载器 2.运行时数据区 3.执行引擎 4.本地接口 5.本地库

### JVM内存分为哪几部分？
1.程序计数器 2.堆内存区 3.虚拟机栈 4.本地方法栈 5元数据区（本地方法区）

* 程序计数器：线程私有，是记录当前线所执行的程字节码运行到哪里的行号记录器。如果执行的是一个Java方法，程序计数器记录的是字节码指令的地址，如果执行的本地方法栈，程序计数器的内容是undefined。 该区域是JVM中唯一一块不会内存溢出的区域。
* 虚拟机栈（Stack）：栈内存是线程私有，一个线程的栈内存里记录每一个方法的入栈和出栈的过程，存放着当前线程的局部变量，操作数，动态链接，方法出口等。
* 本地方法栈：和虚拟机栈一样，为线程提供Native方法
* 堆（Hea）：线程共有的，类创建的对象都在堆内存中，所以也是垃圾回收主要工作的区域。
* 元数据区（MetaSpace）： Java8之后，放弃了永久代，把原来的方法去放在了元数据区中了。

### 
系统是32位还是64位可以通过System.getProperties("sun.arch.data.model");获取。
32位机器JVM理论的最大内存2^32次4G，64位机器的JVM的最大内存可以设置到100G甚至1000G。

### 类加载的过程
A a = new A();
1.加载：当虚拟机遇到了new 关键字，会先去检查这个指令的参数在常量池中是否能找到已经加载的类。如果没有继续执行
2.开始为对象在堆内存中分配内存空间，有可能是连续的也有可能是不连续的。如果有多个线程同时移动指针为对象分配内存空间时，就会出现问题。
3.为对象分配完内存空间后就给内存空间附初始值（0，0L，null，false）等
4.设置对象的其他信息，对象头等。包括这个对象所属的类，类的元数据信息，对象的 hashcode ，GC 分代年龄等信息。
5.最后执行init方法，之前只是设置了对象的初始值并没有进行赋值。
